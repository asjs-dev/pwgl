const e=()=>{},t=(()=>{const t={fps:0,delay:0};let s=0,i=0,n=0,o=Date.now();return t.update=()=>{const e=Date.now();s++,t.delay=(e-o)/16.6667,o=e,e>=n&&(t.fps=1e3*s/(e-i),i=e,n=e+1e3,s=0)},t.init=t.start=e,t})();class s{constructor(){this._state={},this._timestamp={},this._duration={}}isDown(e){return 0===this._state[e]}isUp(e){return 1===this._state[e]}isPressed(e){return this.isUp(e)&&this._duration[e]<=200}isLongPressed(e){return this.isUp(e)&&this._duration[e]>200}getDuration(e){return Date.now()-this._timestamp[e]}update(){for(let e in this._state)this._state[e]&&(delete this._state[e],delete this._duration[e],delete this._timestamp[e])}$setDownState(e){this._state[e]=0,this._timestamp[e]=Date.now()}$setUpState(e){const t=Date.now();this._state[e]=1,this._duration[e]=t-this._timestamp[e],this._timestamp[e]=t}}const i=e=>{if("object"!=typeof e||null==e)return e;const t=Object.getOwnPropertyNames(e);let s,n=Array.isArray(e)?[]:{},o=t.length;for(;s=t[--o];)n[s]="object"==typeof e[s]?i(e[s]):e[s];return n},n=(e,t,s)=>s*e+(1-s)*t;class o{get volume(){return this._volume}set volume(e){this._volume=e,this.$nodesConnected&&(this.$gainNode.gain.value=e)}get pan(){return this._pan}set pan(e){this._pan=e,this.$nodesConnected&&(this.$panNode.pan.value=e)}get reverbDelayTime(){return this._reverbDelayTime}set reverbDelayTime(e){this._reverbDelayTime=e,this.$nodesConnected&&(this.$delayNode.delayTime.value=e)}get reverbFeedbackGain(){return this._reverbFeedbackGain}set reverbFeedbackGain(e){this._reverbFeedbackGain=e,this.$nodesConnected&&(this.$feedbackGainNode.gain.value=e)}get lowPassFilterFrequency(){return this._lowPassFilterFrequency}set lowPassFilterFrequency(e){this._lowPassFilterFrequency=e,this.$nodesConnected&&(this.$lowPassNode.frequency.value=e)}get highPassFilterFrequency(){return this._highPassFilterFrequency}set highPassFilterFrequency(e){this._highPassFilterFrequency=e,this.$nodesConnected&&(this.$highPassNode.frequency.value=e)}$createNodes(e){e&&(this.$gainNode=e.createGain(),this.$panNode=e.createStereoPanner(),this.$delayNode=e.createDelay(),this.$feedbackGainNode=e.createGain(),this.$lowPassNode=e.createBiquadFilter(),this.$lowPassNode.type="lowpass",this.$highPassNode=e.createBiquadFilter(),this.$highPassNode.type="highpass",this.$nodesCreated=!0)}$connectNodes(e){e&&this.$nodesCreated&&(this.$gainNode.connect(this.$panNode),this.$panNode.connect(this.$delayNode),this.$delayNode.connect(this.$feedbackGainNode),this.$feedbackGainNode.connect(this.$delayNode),this.$delayNode.connect(this.$highPassNode),this.$highPassNode.connect(this.$lowPassNode),this.$lowPassNode.connect(e),this.$nodesConnected=!0)}$disconnectNodes(){this.$nodesConnected&&(this.$gainNode.disconnect(),this.$panNode.disconnect(),this.$delayNode.disconnect(),this.$feedbackGainNode.disconnect(),this.$lowPassNode.disconnect(),this.$gainNode=this.$panNode=this.$delayNode=this.$feedbackGainNode=this.$lowPassNode=null,this.$nodesConnected=this.$nodesCreated=!1)}$setConfig(e){this.volume=e.volume??1,this.pan=e.pan??0,this.reverbDelayTime=e.reverbDelayTime??0,this.reverbFeedbackGain=e.reverbFeedbackGain??0,this.lowPassFilterFrequency=e.lowPassFilterFrequency??22050,this.highPassFilterFrequency=e.highPassFilterFrequency??0}}const a=window.PWGL?class extends PWGL.Image{constructor(e={}){super(),this._framebuffer=new PWGL.Framebuffer,this.lightRenderer=new PWGL.LightRenderer(e),this._filter=new PWGL.BlurFilter,this.filterRenderer=new PWGL.FilterRenderer({context:this.lightRenderer.context,sourceTexture:this._framebuffer,filters:[this._filter]}),this.filterRenderer.clearColor.set(0,0,0,0),this.filterRenderer.clearBeforeRender=!0,this.addLightForRender=this.lightRenderer.addLightForRender.bind(this.lightRenderer),this.blendMode=PWGL.BlendMode.SHADOW,this._filterFramebuffer=new PWGL.Framebuffer,this.texture=this._filterFramebuffer,this.blur="number"==typeof e.blur?e.blur:1}get blur(){return this._blur}set blur(e){this._blur=this._filter.intensityX=this._filter.intensityY=e}render(){this._resizeFunc(),this.lightRenderer.renderToFramebuffer(this._framebuffer),this.filterRenderer.renderToFramebuffer(this._filterFramebuffer)}setSize(e,t){this._width=e,this._height=t,this._resizeFunc=this._resize}_resize(){this._resizeFunc=e,this.lightRenderer.setSize(this._width,this._height),this.filterRenderer.setSize(this._width,this._height)}}:null,r=window.PWGL?class extends PWGL.Container{constructor(e,t=1,s=0,i=1){super(),this._width=1,this._height=1;const n=PWGL.Texture.loadImage(e);n.magFilter=PWGL.Const.LINEAR,this._backdropImage=new PWGL.Image,this.addChild(this._backdropImage),this._waterDisplacementImageLarge=new PWGL.Image(n),this._waterDisplacementImageLarge.blendMode=PWGL.BlendMode.ADD,this._waterDisplacementImageLarge.textureTransform.repeatX=.7,this._waterDisplacementImageLarge.tintType=PWGL.TintType.GRAYSCALE,this.addChild(this._waterDisplacementImageLarge),this._waterDisplacementImageSmall=new PWGL.Image(n),this._waterDisplacementImageSmall.blendMode=PWGL.BlendMode.ADD,this._waterDisplacementImageSmall.textureTransform.repeatX=4,this._waterDisplacementImageSmall.textureTransform.repeatRandomRotation=1,this._waterDisplacementImageSmall.tintType=PWGL.TintType.GRAYSCALE,this.addChild(this._waterDisplacementImageSmall),this.speed=t,this.level=s,this.scale=i,this._moveTarget={x:0,y:0},this._wave=0}get speed(){return this._speed}set speed(e){this._speed=e}get scale(){return this._scale}set scale(e){this._scale=e,this._waterDisplacementImageLarge.color.set(0,.1*e,.75,1),this._waterDisplacementImageSmall.color.set(0,.06*e,.75,1)}get level(){return this._level}set level(e){this._level=e,this._backdropImage.color.g=e}setSize(e,t){this._width=e,this._height=t;const s=t/e;this._waterDisplacementImageSmall.transform.width=this._waterDisplacementImageLarge.transform.width=this._backdropImage.transform.width=e,this._waterDisplacementImageSmall.transform.height=this._waterDisplacementImageLarge.transform.height=this._backdropImage.transform.height=t,this._waterDisplacementImageSmall.textureTransform.repeatY=this._waterDisplacementImageSmall.textureTransform.repeatX*s,this._waterDisplacementImageLarge.textureTransform.repeatY=this._waterDisplacementImageLarge.textureTransform.repeatX*s}render(e){const t=this._speed*e,s=2*t;this._wave+=2.5*t;const i=.3*Math.sin(this._wave),n=.3*Math.cos(this._wave);let o=this._waterDisplacementImageLarge.textureTransform;o.x=this._moveTarget.x*o.repeatX+(.75*t+i)%1,o.y=this._moveTarget.y*o.repeatY+(.75*s+n)%1,o=this._waterDisplacementImageSmall.textureTransform,o.x=this._moveTarget.x*o.repeatX+(2*t-i)%1,o.y=this._moveTarget.y*o.repeatY+(2*s-n)%1}move(e,t){this._moveTarget.x=e/this._width,this._moveTarget.y=t/this._height}}:null,h=(e,t)=>{if(e===t)return!0;if(typeof e!=typeof t)return!1;if("object"!=typeof e||null===e||null===t)return!1;const s=Object.getOwnPropertyNames(e),i=Object.getOwnPropertyNames(t);if(s.length!==i.length)return!1;let n,o,a,r,d=s.length;for(;n=s[--d];)if(o=e[n],a=t[n],o!==a&&(r=!1,"object"==typeof o&&"object"==typeof a&&(r=h(o,a)),!r))return!1;return!0},d=(e,t)=>e.x*t.y-e.y*t.x,c=(e,t)=>e.x*t.x+e.y*t.y,l=(e,t)=>{const s=e.b.y-e.a.y,i=e.b.x-e.a.x,n=t.b.y-t.a.y,o=i*n-(t.b.x-t.a.x)*s;if(0!==o){const s=t.b.x-e.a.x,a=t.a.x-t.b.x,r=t.b.y-e.a.y,h=(n*s+a*r)/o,d=((e.a.y-e.b.y)*s+i*r)/o;if(h>0&&h<1&&d>0&&d<1)return{lambda:h,gamma:d}}},u=(e,t)=>e.width>t.x&&e.x<t.width&&e.height>t.y&&e.y<t.height,m=e=>e%1,_=e=>e[Math.floor(Math.random()*e.length)],p=(e,t,s)=>e+t*s,g=(e,t)=>({x:e%t,y:~~(e/t)});let y=1;window.PWGLExtensions=window.AGLExtensions={version:"3.0.1",controls:{PressState:s,Mouse:class extends s{constructor(e){super(),this.position={x:0,y:0},this._target=e??window,this._typeMap={mousedown:1,mouseup:1,touchstart:0,touchend:0},this._onMouseDown=this._onMouseDown.bind(this),this._onMouseUp=this._onMouseUp.bind(this),this._onMouseMove=this._onMouseMove.bind(this),this._target.addEventListener("mousedown",this._onMouseDown),this._target.addEventListener("mouseup",this._onMouseUp),this._target.addEventListener("mousemove",this._onMouseMove),this._target.addEventListener("touchstart",this._onMouseDown),this._target.addEventListener("touchend",this._onMouseUp),this._target.addEventListener("touchmove",this._onMouseMove)}destruct(){this._target.removeEventListener("mousedown",this._onMouseDown),this._target.removeEventListener("mouseup",this._onMouseUp),this._target.removeEventListener("mousemove",this._onMouseMove),this._target.removeEventListener("touchstart",this._onMouseDown),this._target.removeEventListener("touchend",this._onMouseUp),this._target.removeEventListener("touchmove",this._onMouseMove)}_onMouseDown(e){this._typeMap[e.type]===e.which&&this.$setDownState(0)}_onMouseUp(e){this._typeMap[e.type]===e.which&&this.$setUpState(0)}_onMouseMove(e){const t="touchmove"===e.type?e.touches[0]:e;this.position.x=t.clientX,this.position.y=t.clientY}},Keyboard:class extends s{constructor(e){super(),this._target=e??window,this._onKeyDown=this._onKeyDown.bind(this),this._onKeyUp=this._onKeyUp.bind(this),this._target.addEventListener("keydown",this._onKeyDown),this._target.addEventListener("keyup",this._onKeyUp)}destruct(){this._target.removeEventListener("keydown",this._onKeyDown),this._target.removeEventListener("keyup",this._onKeyUp)}_onKeyDown(e){this.$setDownState(e.key)}_onKeyUp(e){this.$setUpState(e.key)}},Gamepad:class{get gamepads(){return navigator.getGamepads?navigator.getGamepads():navigator.webkitGetGamepads||[]}get(e){const t=this.gamepads[e];return t?{axes:t.axes.map(e=>Math.abs(e)>=.05?e:0),buttons:t.buttons.map(e=>"number"==typeof e?{pressed:1===e,touched:1===e,value:e}:e),timestamp:t.timestamp}:null}}},audio:{AudioItem:class extends o{constructor(e=null,t={}){super(),this.$setConfig(t),this.load(e)}get loop(){return this._loop}set loop(e){this._loop=e,this.$nodesConnected&&(this._source.loop=e)}get pitch(){return this._pitch}set pitch(e){this._pitch=e,this.$nodesConnected&&(this._source.playbackRate.value=e)}async load(e){e&&(this.url=e,this._audioResponse=await fetch(e),this._update())}unload(){this.disconnect(),this._buffer=null}connect(e){this._audioMixer!==e&&(this.disconnect(),this._audioMixer=e,this._update(),e.connect(this))}disconnect(){this._audioMixer&&(this.stop(),this._audioMixer.disconnect(this),this._audioMixer=null)}play(e=0){this.stop(),this.isPlaying=!0;const t=this._audioMixer,s=t.context;if(this.$createNodes(s),this.$connectNodes(t.node),s){this._startTime=s.currentTime;try{this.$nodesConnected&&this._source.start(s.currentTime,e)}catch{}}this.$setConfig(this)}stop(){this.isPlaying=!1;const e=this._audioMixer,t=this._buffer;e&&t&&(this._startTime=(e.context.currentTime-this._startTime)%t.duration),this.$disconnectNodes()}resume(){this.play(this._startTime)}$createNodes(e){const t=this._buffer;e&&t&&(this._source=e.createBufferSource(),this._source.buffer=t,super.$createNodes(e))}$connectNodes(e){e&&this.$nodesCreated&&(this._source.connect(this.$gainNode),super.$connectNodes(e))}$disconnectNodes(){this.$nodesConnected&&(this._source.stop(),this._source.disconnect(),this._source=null,super.$disconnectNodes())}$setConfig(e={}){this.loop=e.loop??!1,this.pitch=e.pitch??1,super.$setConfig(e)}async _update(){const e=this._audioResponse,t=this._audioMixer;if(e&&t){const s=await e.arrayBuffer();this._buffer=await t.context.decodeAudioData(s),this.isPlaying&&this.play()}}},AudioMixer:class extends o{constructor(e={}){super();const t=new(window.AudioContext||window.webkitAudioContext);this._context=t,this._items=[],this.$createNodes(t),this.$connectNodes(t.destination),this.$setConfig(e)}get context(){return this._context}get node(){return this.$gainNode}play(){this._items.forEach(e=>e.play())}stop(){this._items.forEach(e=>e.stop())}destruct(){this.stop(),this.$disconnectNodes()}resume(){this._items.forEach(e=>e.resume())}connect(e){this._items.includes(e)||(this._items.push(e),e.connect(this))}disconnect(e){this._items.includes(e)&&(this._items.splice(this._items.indexOf(e),1),e.disconnect())}},fadeAudioVolume:(e,t,s,i)=>e.volume=n(t,s,i),crossFadeAudioVolumes:(e,t,s,i,o)=>{const a=n(s,i,o);e.volume=a,t.volume=1-a}},display:{AnimatedWater:r,SmoothLight:a},utils:{FPS:t,createDataObserver:(e={})=>{let t=!1,s=i(e);const n=new Proxy(e,{set:(e,s,i)=>(t=!0,e[s]=i,!0)});return{state:n,flush:()=>{if(!t)return null;const e=i(n),o=s;return s=e,t=!1,{state:e,prevState:o}}}},areObjectsEqual:h,clamp:(e,t,s)=>Math.max(e,Math.min(t,s)),mix:n,clone:i,collisionDetection:{distanceBetweenPointAndLine:(e,t)=>{const s={x:t.b.x-t.a.x,y:t.b.y-t.a.y},i={x:e.x-t.a.x,y:e.y-t.a.y},n={x:e.x-t.b.x,y:e.y-t.b.y},o=c(s,i)<0,a=c(s,n)>0;if(!o&&!a)return Math.abs(d(s,i))/Math.hypot(s.x,s.y);const r=o?i:n;return Math.hypot(r.x,r.y)},areTwoLinesCollided:l,lineToLineIntersection:(e,t)=>{const s=l(e,t);return s?{x:e.a.x+(e.b.x-e.a.x)*s.lambda,y:e.a.y+(e.b.y-e.a.y)*s.lambda}:null},areTwoRectsCollided:u,rectToRectIntersection:(e,t)=>u(e,t)?{x:Math.max(e.x,t.x),y:Math.max(e.y,t.y),width:Math.min(e.width,t.width),height:Math.min(e.height,t.height)}:null},cross:d,dot:c,enterFrame:(e,s=0)=>{const i={};let n,o,a,r,h,d=Date.now(),c=!1;const l=()=>{t.update(),e(t.fps,t.delay)},u=()=>{const e=Date.now(),t=e-d;t>=r&&(r=2*a-t,d=e,l())},m=()=>{c&&(n(),h=requestAnimationFrame(m))};return i.isPlaying=()=>c,i.clearMaxFPS=()=>{o=1/0,n=l},i.getMaxFPS=()=>o,i.setMaxFPS=e=>{if(!e||e<=0)return i.clearMaxFPS();o=e,r=a=Math.floor(1e3/o)-1,n=u},i.start=()=>{c||(c=!0,m())},i.stop=()=>{cancelAnimationFrame(h),c=!1},i.setMaxFPS(s),i.start(),i},enumCheck:(e,t)=>(e&t)===t,fract:m,getFPS:async()=>new Promise(e=>{requestAnimationFrame(t=>requestAnimationFrame(s=>e(Math.round(1e3/(s-t)))))}),nthCall:(e,t,s=0)=>{let i=t-(s+1);return(...s)=>!(i=i>-1?(1+i)%t:++i)&&e(...s)},generateDungeon:(e,t)=>{const s=[{x:1,y:0},{x:1,y:1},{x:0,y:1},{x:-1,y:1},{x:-1,y:0},{x:-1,y:-1},{x:0,y:-1}],i=[];let n=1/0,o=1/0,a=-1/0,r=-1/0;for(let l=0;l<e;l++){const e=_(s),h=clone(_(t));Math.random()<.5&&h.data.reverse();const d={...h,x:0,y:0};let c=100;for(;c--;){let t=!1;for(const s of i)if(u({x:s.x,y:s.y,width:s.x+s.width,height:s.y+s.height},{x:d.x,y:d.y,width:d.x+d.width,height:d.y+d.height})){const s=Math.random()-.5,i=Math.round(2*(Math.random()-.5));d.x+=e.x&&(s>=0||!e.y)?e.x:i,d.y+=e.y&&(s<0||!e.x)?e.y:i,t=!0;break}if(!t)break}n=Math.min(d.x,n),o=Math.min(d.y,o),a=Math.max(d.x+d.width,a),r=Math.max(d.y+d.height,r),i.push(d)}const h=a-n,d=r-o,c=Array(h*d).fill(0);i.forEach(({x:e,y:t,width:s,height:i,data:a})=>{const r=e-n,d=t-o;a.forEach((e,t)=>{const{x:i,y:n}=g(t,s);c[p(r+i,d+n,h)]=e})});for(let l=0,u=c.length-h;l<u;l++){const{x:e,y:t}=g(l,h);if(e<h-1&&c[l]>0){const s=p(e,t+1,h),i=p(e+1,t,h),n=p(e+1,t+1,h),o=p(e-1,t,h),a=p(e-1,t+1,h);c[s]===c[i]&&c[l]===c[n]&&c[l]!==c[i]&&(c[s]=c[i]=1),e>0&&c[s]===c[o]&&c[l]===c[a]&&c[l]!==c[o]&&(c[s]=c[o]=1)}}return{width:h,height:d,data:c}},noop:e,noopReturnsWith:e=>()=>e,arraySet:(e,t,s=0)=>{let i=t.length;for(;--i>-1;)e[s+i]=t[i];return e},removeFromArray:(e,t)=>{const s=e.indexOf(t);s>-1&&e.splice(s,1)},gridMapping:{coordToVector:p,vectorToCoord:g},random:{getRandomFrom:_,hashNoise2D:(e,t,s)=>.5*m(Math.sin(c({x:e,y:t},{x:Math.sin(e+t),y:Math.cos(t-e)*s}))*s)+.5,stepNoise:(e,t,s)=>y=Math.abs(m(y*(.12+34.56*e+s*t*78.9)))}}},console.log(`%cPWGL Extensions v${AGLExtensions.version}\nhttps://github.com/asjs-dev/pwgl`,"background:#222;color:#0F0");
