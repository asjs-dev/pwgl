const e=()=>{},t=(()=>{const t={fps:0,delay:0};let s=0,i=0,n=0,a=Date.now();return t.update=()=>{const e=Date.now();s++,t.delay=(e-a)/16.6667,a=e,e>=n&&(t.fps=1e3*s/(e-i),i=e,n=e+1e3,s=0)},t.init=t.start=e,t})();class s{constructor(){this._state={},this._timestamp={},this._duration={}}isDown(e){return 0===this._state[e]}isUp(e){return 1===this._state[e]}isPressed(e){return this.isUp(e)&&this._duration[e]<=200}isLongPressed(e){return this.isUp(e)&&this._duration[e]>200}getDuration(e){return Date.now()-this._timestamp[e]}update(){for(let e in this._state)this._state[e]&&(delete this._state[e],delete this._duration[e],delete this._timestamp[e])}$setDownState(e){this._state[e]=0,this._timestamp[e]=Date.now()}$setUpState(e){const t=Date.now();this._state[e]=1,this._duration[e]=t-this._timestamp[e],this._timestamp[e]=t}}const i=(e,t)=>{if(typeof e!=typeof t)return!1;if("object"!=typeof e)return e===t;const s=Object.getOwnPropertyNames(e),n=Object.getOwnPropertyNames(t);if(s.length!==n.length)return!1;let a,o,r,h,d=s.length;for(;a=s[--d];)if(o=e[a],r=t[a],o!==r&&(h=!1,"object"==typeof o&&"object"==typeof r&&(h=i(o,r)),!h))return!1;return!0},n=e=>{if("object"!=typeof e||null==e)return e;const t=Object.getOwnPropertyNames(e);let s,i=Array.isArray(e)?[]:{},a=t.length;for(;s=t[--a];)i[s]="object"==typeof e[s]?n(e[s]):e[s];return i};const a=(e,t,s)=>s*e+(1-s)*t;class o{get volume(){return this._volume}set volume(e){this._volume=e,this.$nodesConnected&&(this.$gainNode.gain.value=e)}get pan(){return this._pan}set pan(e){this._pan=e,this.$nodesConnected&&(this.$panNode.pan.value=e)}get reverbDelayTime(){return this._reverbDelayTime}set reverbDelayTime(e){this._reverbDelayTime=e,this.$nodesConnected&&(this.$delayNode.delayTime.value=e)}get reverbFeedbackGain(){return this._reverbFeedbackGain}set reverbFeedbackGain(e){this._reverbFeedbackGain=e,this.$nodesConnected&&(this.$feedbackGainNode.gain.value=e)}get lowPassFilterFrequency(){return this._lowPassFilterFrequency}set lowPassFilterFrequency(e){this._lowPassFilterFrequency=e,this.$nodesConnected&&(this.$lowPassNode.frequency.value=e)}get highPassFilterFrequency(){return this._highPassFilterFrequency}set highPassFilterFrequency(e){this._highPassFilterFrequency=e,this.$nodesConnected&&(this.$highPassNode.frequency.value=e)}$createNodes(e){e&&(this.$gainNode=e.createGain(),this.$panNode=e.createStereoPanner(),this.$delayNode=e.createDelay(),this.$feedbackGainNode=e.createGain(),this.$lowPassNode=e.createBiquadFilter(),this.$lowPassNode.type="lowpass",this.$highPassNode=e.createBiquadFilter(),this.$highPassNode.type="highpass",this.$nodesCreated=!0)}$connectNodes(e){e&&this.$nodesCreated&&(this.$gainNode.connect(this.$panNode),this.$panNode.connect(this.$delayNode),this.$delayNode.connect(this.$feedbackGainNode),this.$feedbackGainNode.connect(this.$delayNode),this.$delayNode.connect(this.$highPassNode),this.$highPassNode.connect(this.$lowPassNode),this.$lowPassNode.connect(e),this.$nodesConnected=!0)}$disconnectNodes(){this.$nodesConnected&&(this.$gainNode.disconnect(),this.$panNode.disconnect(),this.$delayNode.disconnect(),this.$feedbackGainNode.disconnect(),this.$lowPassNode.disconnect(),this.$gainNode=this.$panNode=this.$delayNode=this.$feedbackGainNode=this.$lowPassNode=null,this.$nodesConnected=this.$nodesCreated=!1)}$setConfig(e){this.volume=e.volume??1,this.pan=e.pan??0,this.reverbDelayTime=e.reverbDelayTime??0,this.reverbFeedbackGain=e.reverbFeedbackGain??0,this.lowPassFilterFrequency=e.lowPassFilterFrequency??22050,this.highPassFilterFrequency=e.highPassFilterFrequency??0}}const r=window.AGL?class extends AGL.Image{constructor(e={}){super(),this._framebuffer=new AGL.Framebuffer,this.lightRenderer=new AGL.LightRenderer(e),this._filter=new AGL.BlurFilter,this.filterRenderer=new AGL.FilterRenderer({context:this.lightRenderer.context,sourceTexture:this._framebuffer,filters:[this._filter]}),this.filterRenderer.clearColor.set(0,0,0,0),this.filterRenderer.clearBeforeRender=!0,this.addLightForRender=this.lightRenderer.addLightForRender.bind(this.lightRenderer),this.blendMode=AGL.BlendMode.SHADOW,this._filterFramebuffer=new AGL.Framebuffer,this.texture=this._filterFramebuffer,this.blur="number"==typeof e.blur?e.blur:1}get blur(){return this._blur}set blur(e){this._blur=this._filter.intensityX=this._filter.intensityY=e}render(){this._resizeFunc(),this.lightRenderer.renderToFramebuffer(this._framebuffer),this.filterRenderer.renderToFramebuffer(this._filterFramebuffer)}setSize(e,t){this._width=e,this._height=t,this._resizeFunc=this._resize}_resize(){this._resizeFunc=e,this.lightRenderer.setSize(this._width,this._height),this.filterRenderer.setSize(this._width,this._height)}}:null,h=window.AGL?class extends AGL.Container{constructor(e,t=1,s=0,i=1){super(),this._width=1,this._height=1;const n=AGL.Texture.loadImage(e);n.magFilter=AGL.Const.LINEAR,this._backdropImage=new AGL.Image,this.addChild(this._backdropImage),this._waterDisplacementImageLarge=new AGL.Image(n),this._waterDisplacementImageLarge.blendMode=AGL.BlendMode.ADD,this._waterDisplacementImageLarge.textureTransform.repeatX=.7,this._waterDisplacementImageLarge.tintType=AGL.Image.TintType.GRAYSCALE,this.addChild(this._waterDisplacementImageLarge),this._waterDisplacementImageSmall=new AGL.Image(n),this._waterDisplacementImageSmall.blendMode=AGL.BlendMode.ADD,this._waterDisplacementImageSmall.textureTransform.repeatX=4,this._waterDisplacementImageSmall.textureTransform.repeatRandomRotation=1,this._waterDisplacementImageSmall.tintType=AGL.Image.TintType.GRAYSCALE,this.addChild(this._waterDisplacementImageSmall),this.speed=t,this.level=s,this.scale=i,this._moveTarget={x:0,y:0},this._wave=0}get speed(){return this._speed}set speed(e){this._speed=e}get scale(){return this._scale}set scale(e){this._scale=e,this._waterDisplacementImageLarge.color.set(0,.1*e,.75,1),this._waterDisplacementImageSmall.color.set(0,.06*e,.75,1)}get level(){return this._level}set level(e){this._level=e,this._backdropImage.color.g=e}setSize(e,t){this._width=e,this._height=t;const s=t/e;this._waterDisplacementImageSmall.transform.width=this._waterDisplacementImageLarge.transform.width=this._backdropImage.transform.width=e,this._waterDisplacementImageSmall.transform.height=this._waterDisplacementImageLarge.transform.height=this._backdropImage.transform.height=t,this._waterDisplacementImageSmall.textureTransform.repeatY=this._waterDisplacementImageSmall.textureTransform.repeatX*s,this._waterDisplacementImageLarge.textureTransform.repeatY=this._waterDisplacementImageLarge.textureTransform.repeatX*s}render(e){const t=this._speed*e,s=2*t;this._wave+=2.5*t;const i=.3*Math.sin(this._wave),n=.3*Math.cos(this._wave);let a=this._waterDisplacementImageLarge.textureTransform;a.x=this._moveTarget.x*a.repeatX+(.75*t+i)%1,a.y=this._moveTarget.y*a.repeatY+(.75*s+n)%1,a=this._waterDisplacementImageSmall.textureTransform,a.x=this._moveTarget.x*a.repeatX+(2*t-i)%1,a.y=this._moveTarget.y*a.repeatY+(2*s-n)%1}move(e,t){this._moveTarget.x=e/this._width,this._moveTarget.y=t/this._height}}:null,d=(e,t)=>e.x*t.y-e.y*t.x,c=(e,t)=>e.x*t.x+e.y*t.y,l=(e,t)=>{const s=e.b.y-e.a.y,i=e.b.x-e.a.x,n=t.b.y-t.a.y,a=i*n-(t.b.x-t.a.x)*s;if(0!==a){const s=t.b.x-e.a.x,o=t.a.x-t.b.x,r=t.b.y-e.a.y,h=(n*s+o*r)/a,d=((e.a.y-e.b.y)*s+i*r)/a;if(h>0&&h<1&&d>0&&d<1)return{lambda:h,gamma:d}}},u=(e,t)=>e.width>t.x&&e.x<t.width&&e.height>t.y&&e.y<t.height,m={distanceBetweenPointAndLine:(e,t)=>{const s={x:t.b.x-t.a.x,y:t.b.y-t.a.y},i={x:e.x-t.a.x,y:e.y-t.a.y},n={x:e.x-t.b.x,y:e.y-t.b.y},a=c(s,i)<0,o=c(s,n)>0;if(!a&&!o)return Math.abs(d(s,i))/Math.hypot(s.x,s.y);const r=a?i:n;return Math.hypot(r.x,r.y)},areTwoLinesCollided:l,lineToLineIntersection:(e,t)=>{const s=l(e,t);return s?{x:e.a.x+(e.b.x-e.a.x)*s.lambda,y:e.a.y+(e.b.y-e.a.y)*s.lambda}:null},areTwoRectsCollided:u,rectToRectIntersection:(e,t)=>u(e,t)?{x:Math.max(e.x,t.x),y:Math.max(e.y,t.y),width:Math.min(e.width,t.width),height:Math.min(e.height,t.height)}:null},_=e=>e%1;let p=1;const g={rand:(e,t,s)=>p=Math.abs(_(p*(.12+34.56*e+s*t*78.9))),fixRand:(e,t,s)=>.5*_(Math.sin(dot({x:e,y:t},{x:Math.sin(e+t),y:Math.cos(t-e)*s}))*s)+.5},y=e=>e[Math.floor(Math.random()*e.length)],w={coordToVector:(e,t,s)=>e+t*s,vectorToCoord:(e,t)=>({x:e%t,y:~~(e/t)})};window.PWGLExtensions=window.AGLExtensions={version:"1.0.1",FPS:t,DataObserver:class{constructor(e={}){this._state=e,this._prevState=n(this._state),this._run=!1,this._checkState=this._checkState.bind(this),this._checkState()}start(){this._run=!0}stop(){this._run=!1}_checkState(){if(this._run&&!i(this._state,this._prevState)){const e=n(this._state),t=n(this._prevState);this._update(e,t),this._prevState=e}requestAnimationFrame(this._checkState)}},PressState:s,Mouse:class extends s{constructor(e){super(),this.position={x:0,y:0},this._target=e??window,this._typeMap={mousedown:1,mouseup:1,touchstart:0,touchend:0},this._onMouseDown=this._onMouseDown.bind(this),this._onMouseUp=this._onMouseUp.bind(this),this._onMouseMove=this._onMouseMove.bind(this),this._target.addEventListener("mousedown",this._onMouseDown),this._target.addEventListener("mouseup",this._onMouseUp),this._target.addEventListener("mousemove",this._onMouseMove),this._target.addEventListener("touchstart",this._onMouseDown),this._target.addEventListener("touchend",this._onMouseUp),this._target.addEventListener("touchmove",this._onMouseMove)}destruct(){this._target.removeEventListener("mousedown",this._onMouseDown),this._target.removeEventListener("mouseup",this._onMouseUp),this._target.removeEventListener("mousemove",this._onMouseMove),this._target.removeEventListener("touchstart",this._onMouseDown),this._target.removeEventListener("touchend",this._onMouseUp),this._target.removeEventListener("touchmove",this._onMouseMove)}_onMouseDown(e){this._typeMap[e.type]===e.which&&this.$setDownState(0)}_onMouseUp(e){this._typeMap[e.type]===e.which&&this.$setUpState(0)}_onMouseMove(e){const t="touchmove"===e.type?e.touches[0]:e;this.position.x=t.clientX,this.position.y=t.clientY}},Keyboard:class extends s{constructor(e){super(),this._target=e??window,this._onKeyDown=this._onKeyDown.bind(this),this._onKeyUp=this._onKeyUp.bind(this),this._target.addEventListener("keydown",this._onKeyDown),this._target.addEventListener("keyup",this._onKeyUp)}destruct(){this._target.removeEventListener("keydown",this._onKeyDown),this._target.removeEventListener("keyup",this._onKeyUp)}_onKeyDown(e){this.$setDownState(e.key)}_onKeyUp(e){this.$setUpState(e.key)}},Gamepad:class{get gamepads(){return navigator.getGamepads?navigator.getGamepads():navigator.webkitGetGamepads||[]}get(e){const t=this.gamepads[e];return t?{axes:t.axes.map(e=>Math.abs(e)>=.05?e:0),buttons:t.buttons.map(e=>"number"==typeof e?{pressed:1===e,touched:1===e,value:e}:e),timestamp:t.timestamp}:null}},AudioItem:class extends o{constructor(e=null,t={}){super(),this.$setConfig(t),this.load(e)}get loop(){return this._loop}set loop(e){this._loop=e,this.$nodesConnected&&(this._source.loop=e)}get pitch(){return this._pitch}set pitch(e){this._pitch=e,this.$nodesConnected&&(this._source.playbackRate.value=e)}async load(e){e&&(this.url=e,this._audioResponse=await fetch(e),this._update())}unload(){this.disconnect(),this._buffer=null}connect(e){this._audioMixer!==e&&(this.disconnect(),this._audioMixer=e,this._update(),e.connect(this))}disconnect(){this._audioMixer&&(this.stop(),this._audioMixer.disconnect(this),this._audioMixer=null)}play(e=0){this.stop(),this.isPlaying=!0;const t=this._audioMixer,s=t.context;if(this.$createNodes(s),this.$connectNodes(t.node),s){this._startTime=s.currentTime;try{this.$nodesConnected&&this._source.start(s.currentTime,e)}catch(i){}}this.$setConfig(this)}stop(){this.isPlaying=!1;const e=this._audioMixer,t=this._buffer;e&&t&&(this._startTime=(e.context.currentTime-this._startTime)%t.duration),this.$disconnectNodes()}resume(){this.play(this._startTime)}$createNodes(e){const t=this._buffer;e&&t&&(this._source=e.createBufferSource(),this._source.buffer=t,super.$createNodes(e))}$connectNodes(e){e&&this.$nodesCreated&&(this._source.connect(this.$gainNode),super.$connectNodes(e))}$disconnectNodes(){this.$nodesConnected&&(this._source.stop(),this._source.disconnect(),this._source=null,super.$disconnectNodes())}$setConfig(e={}){this.loop=e.loop??!1,this.pitch=e.pitch??1,super.$setConfig(e)}async _update(){const e=this._audioResponse,t=this._audioMixer;if(e&&t){const s=await e.arrayBuffer();this._buffer=await t.context.decodeAudioData(s),this.isPlaying&&this.play()}}},AudioMixer:class extends o{constructor(e={}){super();const t=new(window.AudioContext||window.webkitAudioContext);this._context=t,this._items=[],this.$createNodes(t),this.$connectNodes(t.destination),this.$setConfig(e)}get context(){return this._context}get node(){return this.$gainNode}play(){this._items.forEach(e=>e.play())}stop(){this._items.forEach(e=>e.stop())}destruct(){this.stop(),this.$disconnectNodes()}resume(){this._items.forEach(e=>e.resume())}connect(e){this._items.includes(e)||(this._items.push(e),e.connect(this))}disconnect(e){this._items.includes(e)&&(this._items.splice(this._items.indexOf(e),1),e.disconnect())}},fadeAudioVolume:(e,t,s,i)=>e.volume=a(t,s,i),crossFadeAudioVolumes:(e,t,s,i,n)=>{const o=a(s,i,n);e.volume=o,t.volume=1-o},SmoothLight:r,AnimatedWater:h,areObjectsEqual:i,clamp:(e,t,s)=>Math.max(e,Math.min(t,s)),mix:a,clone:n,collisionDetection:m,cross:d,dot:c,enterFrame:(e,s=0)=>{const i={};let n,a,o,r,h,d=Date.now(),c=!1;const l=()=>{t.update(),e(t.fps,t.delay)},u=()=>{const e=Date.now(),t=e-d;t>=r&&(r=2*o-t,d=e,l())},m=()=>{c&&(n(),h=requestAnimationFrame(m))};return i.isPlaying=()=>c,i.clearMaxFPS=()=>{a=1/0,n=l},i.getMaxFPS=()=>a,i.setMaxFPS=e=>{if(!e||e<=0)return i.clearMaxFPS();a=e,r=o=Math.floor(1e3/a)-1,n=u},i.start=()=>{c||(c=!0,m())},i.stop=()=>{cancelAnimationFrame(h),c=!1},i.setMaxFPS(s),i.start(),i},enumCheck:(e,t)=>(e&t)===t,fract:_,getFPS:async()=>new Promise(e=>{requestAnimationFrame(t=>requestAnimationFrame(s=>e(Math.round(1e3/(s-t)))))}),nthCall:(e,t,s=0)=>{let i=t-(s+1);return(...s)=>!(i=i>-1?(1+i)%t:++i)&&e(...s)},random:g,generateDungeon:(e,t)=>{const{vectorToCoord:s,coordToVector:i}=w,n=[{x:1,y:0},{x:1,y:1},{x:0,y:1},{x:-1,y:1},{x:-1,y:0},{x:-1,y:-1},{x:0,y:-1}],a=[];let o=1/0,r=1/0,h=-1/0,d=-1/0;for(let _=0;_<e;_++){const e=y(n),s=clone(y(t));Math.random()<.5&&s.data.reverse();const i={...s,x:0,y:0};let c=100;for(;c--;){let t=!1;for(const s of a)if(m.areTwoRectsCollided({x:s.x,y:s.y,width:s.x+s.width,height:s.y+s.height},{x:i.x,y:i.y,width:i.x+i.width,height:i.y+i.height})){const s=Math.random()-.5,n=Math.round(2*(Math.random()-.5));i.x+=e.x&&(s>=0||!e.y)?e.x:n,i.y+=e.y&&(s<0||!e.x)?e.y:n,t=!0;break}if(!t)break}o=Math.min(i.x,o),r=Math.min(i.y,r),h=Math.max(i.x+i.width,h),d=Math.max(i.y+i.height,d),a.push(i)}const c=h-o,l=d-r,u=Array(c*l).fill(0);a.forEach(({x:e,y:t,width:n,height:a,data:h})=>{const d=e-o,l=t-r;h.forEach((e,t)=>{const{x:a,y:o}=s(t,n);u[i(d+a,l+o,c)]=e})});for(let m=0,_=u.length-c;m<_;m++){const{x:e,y:t}=s(m,c);if(e<c-1&&u[m]>0){const s=i(e,t+1,c),n=i(e+1,t,c),a=i(e+1,t+1,c),o=i(e-1,t,c),r=i(e-1,t+1,c);u[s]===u[n]&&u[m]===u[a]&&u[m]!==u[n]&&(u[s]=u[n]=1),e>0&&u[s]===u[o]&&u[m]===u[r]&&u[m]!==u[o]&&(u[s]=u[o]=1)}}return{width:c,height:l,data:u}},noop:e,noopReturnsWith:e=>()=>e,arraySet:(e,t,s=0)=>{let i=t.length;for(;--i>-1;)e[s+i]=t[i];return e},removeFromArray:(e,t)=>{const s=e.indexOf(t);s>-1&&e.splice(s,1)},gridMapping:w,getRandom:y},console.log(`%cPWGL Extensions v${AGLExtensions.version}\nhttps://github.com/asjs-dev/pwgl`,"background:#222;color:#0F0");
